
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cordova-plugin-helper: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bilginyuksel/cordova-plugin-helper/main.go (81.8%)</option>
				
				<option value="file1">github.com/bilginyuksel/cordova-plugin-helper/parser/xml_parser.go (75.0%)</option>
				
				<option value="file2">github.com/bilginyuksel/cordova-plugin-helper/writer/licence_writer.go (73.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        //"github.com/bilginyuksel/cordova-plugin-helper/writer"
        "os"
        "path/filepath"

        parser "github.com/bilginyuksel/cordova-plugin-helper/parser"
)

func main() <span class="cov0" title="0">{
        plg, _ := parser.ParseXML("parser/plugin.xml")
        parser.CreateXML(plg, "plg.xml")
}</span>

func hello() string <span class="cov8" title="1">{
        return "Hello, World"
}</span>

func filePathWalkDir(root string) ([]string, error) <span class="cov8" title="1">{
        var files []string
        err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        files = append(files, path)
                }</span>
                <span class="cov8" title="1">return err</span>
        })
        <span class="cov8" title="1">return files, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package parser

import (
        "encoding/xml"
        "errors"
        "io/ioutil"
        "os"
        "strings"
)

// ParseXML ...
func ParseXML(filename string) (*Plugin, error) <span class="cov8" title="1">{

        if !checkIsAnXMLFile(filename) </span><span class="cov8" title="1">{
                return nil, errors.New("only XML files can be parsed with this method")
        }</span>
        <span class="cov8" title="1">xmlFile, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defer xmlFile.Close()

        byteValue, _ := ioutil.ReadAll(xmlFile)
        var plugin Plugin
        xml.Unmarshal(byteValue, &amp;plugin)
        return &amp;plugin, nil</span>
}

// CreateXML ...
func CreateXML(plugin *Plugin, filename string) error <span class="cov0" title="0">{

        file, _ := xml.MarshalIndent(plugin, "", "\t")
        file = []byte(xml.Header + string(file))
        error := ioutil.WriteFile(filename, file, 0644)
        return error
}</span>

// Plugin ...
type Plugin struct {
        ID           string     `xml:"id,attr"`
        Version      string     `xml:"version,attr"`
        Xmlns        string     `xml:"xmlns,attr"`
        XmlnsAndroid string     `xml:"android,attr"`
        Name         string     `xml:"name"`
        Description  string     `xml:"description"`
        License      string     `xml:"license,"`
        Keywords     string     `xml:"keywords"`
        Author       string     `xml:"author,omitempty"`
        Engines      *Engines   `xml:"engines,omitempty"`
        JsModule     []JSModule `xml:"js-module"`
        Platform     Platform   `xml:"platform"`
}

// Engines ...
type Engines struct {
        Engine []Engine `xml:"engine"`
}

// Platform ...
type Platform struct {
        Name        string       `xml:"name,attr"`
        Hooks       []Hook       `xml:"hook"`
        ConfigFiles []ConfigFile `xml:"config-file"`
        Frameworks  []Framework  `xml:"framework"`
        SourceFiles []SourceFile `xml:"source-file"`
}

// Framework ...
type Framework struct {
        Src    string `xml:"src,attr"`
        Custom bool   `xml:"custom,attr,omitempty"`
        Type   string `xml:"type,attr,omitempty"`
}

// ConfigFile ...
type ConfigFile struct {
        Target          string           `xml:"target,attr,omitempty"`
        Parent          string           `xml:"parent,attr,omitempty"`
        UsesPermissions []UsesPermission `xml:"uses-permission"`
        Receivers       []Receiver       `xml:"receiver"`
        Metadata        *Metadata        `xml:"meta-data,omitempty"`
        Services        []Service        `xml:"service"`
        Features        []Feature        `xml:"feature"`
}

// Feature ...
type Feature struct {
        Name   string  `xml:"name,attr,omitempty"`
        Params []Param `xml:"param"`
}

// Param ...
type Param struct {
        Name  string `xml:"name,attr,omitempty"`
        Value string `xml:"value,attr,omitempty"`
}

// Service ...
type Service struct {
        AndroidName     string         `xml:"name,attr,omitempty"`
        AndroidExported bool           `xml:"exported,attr,omitempty"`
        IntentFilters   []IntentFilter `xml:"intent-filter"`
}

// Metadata ...
type Metadata struct {
        AndroidName  string `xml:"value,attr,omitempty"`
        AndroidValue string `xml:"name,attr,omitempty"`
}

// Receiver ...
type Receiver struct {
        AndroidName     string         `xml:"name,attr,omitempty"`
        AndroidEnabled  bool           `xml:"enabled,attr,omitempty"`
        AndroidExported bool           `xml:"exported,attr,omitempty"`
        IntentFilters   []IntentFilter `xml:"intent-filter"`
}

// IntentFilter ...
type IntentFilter struct {
        Actions    []Action   `xml:"action"`
        Categories []Category `xml:"category"`
        Datas      []Data     `xml:"data"`
}

// Category ...
type Category struct {
        AndroidName string `xml:"name,attr"`
}

// Data ...
type Data struct {
        AndroidScheme string `xml:"scheme,attr"`
}

// Action ...
type Action struct {
        AndroidName string `xml:"name,attr"`
}

// UsesPermission ...
type UsesPermission struct {
        AndroidName string `xml:"name,attr"`
}

// Hook ...
type Hook struct {
        Type string `xml:"type,attr"`
        Src  string `xml:"src,attr"`
}

// Engine ...
type Engine struct {
        Name    string `xml:"name,attr"`
        Version string `xml:"version,attr,utf-8"`
}

// SourceFile ...
type SourceFile struct {
        Src       string `xml:"src,attr"`
        TargetDir string `xml:"target-dir,attr"`
}

// JSModule ...
type JSModule struct {
        Name     string    `xml:"name,attr"`
        Src      string    `xml:"src,attr"`
        Clobbers *Clobbers `xml:"clobbers,omitempty"`
}

// Clobbers ...
type Clobbers struct {
        Target string `xml:"target,attr,omitempty"`
}

func checkIsAnXMLFile(filename string) bool <span class="cov8" title="1">{
        splittedString := strings.Split(filename, ".")
        return splittedString[len(splittedString)-1] == "xml"
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package writer

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

const LICENCE = `/*
    Copyright 2020. Huawei Technologies Co., Ltd. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License")
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
`

func CheckIfFileContainsLicenceAlready(fileName string) (bool, error) <span class="cov8" title="1">{
        file, err := os.Open(fileName)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">scanner := bufio.NewScanner(file)
        fileContent := ""
        for scanner.Scan() </span><span class="cov8" title="1">{
                fileContent += scanner.Text() + "\n"
        }</span>
        <span class="cov8" title="1">err = file.Close()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return strings.Contains(fileContent, LICENCE), err</span>
}

func CheckIfLicenceFormatIsValid(file *os.File) bool <span class="cov8" title="1">{
        firstLine := "Copyright 2020. Huawei Technologies Co., Ltd. All rights reserved."
        scanner := bufio.NewScanner(file)
        fileContent := ""
        for scanner.Scan() </span><span class="cov0" title="0">{
                fileContent += scanner.Text() + "\n"
        }</span>
        <span class="cov8" title="1">if strings.Contains(fileContent, firstLine) </span><span class="cov0" title="0">{
                index := strings.Index(fileContent, firstLine)
                tempLicence := ""
                for i := index; fileContent[i-1] != '*' || fileContent[i] != '/'; i++ </span><span class="cov0" title="0">{
                        tempLicence += string(fileContent[i])
                }</span>
                <span class="cov0" title="0">fmt.Println(tempLicence)</span>
        }
        <span class="cov8" title="1">return true</span>
}

func WriteLicenceToFile(fileName string) (bool, error) <span class="cov8" title="1">{
        ok, err := CheckIfFileContainsLicenceAlready(fileName)

        if ok </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // open the file to be appended to for read
        <span class="cov8" title="1">f, err := os.Open(fileName)

        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">defer f.Close()

        // make a temporary outfile
        outfile, err := os.Create("temp.java")

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">defer outfile.Close()


        // append at the start
        _, err = outfile.WriteString(LICENCE)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(f)

        // read the file to be appended to and output all of it
        for scanner.Scan() </span><span class="cov8" title="1">{
                _, err = outfile.WriteString(scanner.Text())
                _, err = outfile.WriteString("\n")
        }</span>

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // ensure all lines are written
        <span class="cov8" title="1">outfile.Sync()
        //close the file to rename it, otherwise error will be thrown
        err = outfile.Close()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">err = f.Close()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // overwrite the old file with the new one
        <span class="cov8" title="1">err = os.Remove(fileName)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">err = os.Rename(outfile.Name(), fileName)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
